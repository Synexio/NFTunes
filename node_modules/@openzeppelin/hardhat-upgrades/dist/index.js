"use strict";
/* eslint-disable @typescript-eslint/no-var-requires */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
require("@nomicfoundation/hardhat-ethers");
require("./type-extensions");
const config_1 = require("hardhat/config");
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const plugins_1 = require("hardhat/plugins");
(0, config_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY, async (args, hre, runSuper) => {
    const { readValidations, ValidationsCacheOutdated, ValidationsCacheNotFound } = await Promise.resolve().then(() => __importStar(require('./utils/validations')));
    try {
        await readValidations(hre);
    }
    catch (e) {
        if (e instanceof ValidationsCacheOutdated || e instanceof ValidationsCacheNotFound) {
            args = { ...args, force: true };
        }
        else {
            throw e;
        }
    }
    return runSuper(args);
});
(0, config_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE, async (args, hre, runSuper) => {
    const { isNamespaceSupported, validate, solcInputOutputDecoder, makeNamespacedInput } = await Promise.resolve().then(() => __importStar(require('@openzeppelin/upgrades-core')));
    const { writeValidations } = await Promise.resolve().then(() => __importStar(require('./utils/validations')));
    // TODO: patch input
    const { output, solcBuild } = await runSuper();
    const { isFullSolcOutput } = await Promise.resolve().then(() => __importStar(require('./utils/is-full-solc-output')));
    if (isFullSolcOutput(output)) {
        const decodeSrc = solcInputOutputDecoder(args.input, output);
        let namespacedOutput = undefined;
        if (isNamespaceSupported(args.solcVersion)) {
            const namespacedInput = makeNamespacedInput(args.input, output);
            namespacedOutput = (await runSuper({ ...args, quiet: true, input: namespacedInput })).output;
            await checkNamespacedCompileErrors(namespacedOutput);
        }
        const validations = validate(output, decodeSrc, args.solcVersion, args.input, namespacedOutput);
        await writeValidations(hre, validations);
    }
    return { output, solcBuild };
});
/**
 * Checks for compile errors in the modified contracts for namespaced storage.
 * If errors are found, throws an error with the compile error messages.
 */
async function checkNamespacedCompileErrors(namespacedOutput) {
    const errors = [];
    if (namespacedOutput.errors !== undefined) {
        for (const error of namespacedOutput.errors) {
            if (error.severity === 'error') {
                errors.push(error.formattedMessage);
            }
        }
    }
    if (errors.length > 0) {
        const { UpgradesError } = await Promise.resolve().then(() => __importStar(require('@openzeppelin/upgrades-core')));
        throw new UpgradesError(`Failed to compile modified contracts for namespaced storage:\n\n${errors.join('\n')}`, () => 'Please report this at https://zpl.in/upgrades/report. If possible, include the source code for the contracts mentioned in the errors above.');
    }
}
(0, config_1.extendEnvironment)(hre => {
    hre.upgrades = (0, plugins_1.lazyObject)(() => {
        return makeUpgradesFunctions(hre);
    });
    warnOnHardhatDefender();
    hre.defender = (0, plugins_1.lazyObject)(() => {
        return makeDefenderFunctions(hre);
    });
});
function warnOnHardhatDefender() {
    if (tryRequire('@openzeppelin/hardhat-defender', true)) {
        const { logWarning } = require('@openzeppelin/upgrades-core');
        logWarning('The @openzeppelin/hardhat-defender package is deprecated.', [
            'Uninstall the @openzeppelin/hardhat-defender package.',
            'OpenZeppelin Defender integration is included as part of the Hardhat Upgrades plugin.',
        ]);
    }
}
(0, config_1.extendConfig)((config) => {
    var _a, _b;
    // Accumulate references to all the compiler settings, including overrides
    const settings = [];
    for (const compiler of config.solidity.compilers) {
        compiler.settings ?? (compiler.settings = {});
        settings.push(compiler.settings);
    }
    for (const compilerOverride of Object.values(config.solidity.overrides)) {
        compilerOverride.settings ?? (compilerOverride.settings = {});
        settings.push(compilerOverride.settings);
    }
    // Enable storage layout in all of them
    for (const setting of settings) {
        setting.outputSelection ?? (setting.outputSelection = {});
        (_a = setting.outputSelection)['*'] ?? (_a['*'] = {});
        (_b = setting.outputSelection['*'])['*'] ?? (_b['*'] = []);
        if (!setting.outputSelection['*']['*'].includes('storageLayout')) {
            setting.outputSelection['*']['*'].push('storageLayout');
        }
    }
});
if (tryRequire('@nomicfoundation/hardhat-verify')) {
    (0, config_1.subtask)('verify:etherscan').setAction(async (args, hre, runSuper) => {
        const { verify } = await Promise.resolve().then(() => __importStar(require('./verify-proxy')));
        return await verify(args, hre, runSuper);
    });
}
function makeFunctions(hre, defender) {
    const { silenceWarnings, getAdminAddress, getImplementationAddress, getBeaconAddress, getImplementationAddressFromBeacon, } = require('@openzeppelin/upgrades-core');
    const { makeDeployProxy } = require('./deploy-proxy');
    const { makeUpgradeProxy } = require('./upgrade-proxy');
    const { makeValidateImplementation } = require('./validate-implementation');
    const { makeValidateUpgrade } = require('./validate-upgrade');
    const { makeDeployImplementation } = require('./deploy-implementation');
    const { makePrepareUpgrade } = require('./prepare-upgrade');
    const { makeDeployBeacon } = require('./deploy-beacon');
    const { makeDeployBeaconProxy } = require('./deploy-beacon-proxy');
    const { makeUpgradeBeacon } = require('./upgrade-beacon');
    const { makeForceImport } = require('./force-import');
    const { makeChangeProxyAdmin, makeTransferProxyAdminOwnership } = require('./admin');
    return {
        silenceWarnings,
        deployProxy: makeDeployProxy(hre, defender),
        upgradeProxy: makeUpgradeProxy(hre, defender), // block on defender
        validateImplementation: makeValidateImplementation(hre),
        validateUpgrade: makeValidateUpgrade(hre),
        deployImplementation: makeDeployImplementation(hre, defender),
        prepareUpgrade: makePrepareUpgrade(hre, defender),
        deployBeacon: makeDeployBeacon(hre, defender), // block on defender
        deployBeaconProxy: makeDeployBeaconProxy(hre, defender),
        upgradeBeacon: makeUpgradeBeacon(hre, defender), // block on defender
        forceImport: makeForceImport(hre),
        admin: {
            changeProxyAdmin: makeChangeProxyAdmin(hre, defender), // block on defender
            transferProxyAdminOwnership: makeTransferProxyAdminOwnership(hre, defender), // block on defender
        },
        erc1967: {
            getAdminAddress: (proxyAddress) => getAdminAddress(hre.network.provider, proxyAddress),
            getImplementationAddress: (proxyAddress) => getImplementationAddress(hre.network.provider, proxyAddress),
            getBeaconAddress: (proxyAddress) => getBeaconAddress(hre.network.provider, proxyAddress),
        },
        beacon: {
            getImplementationAddress: (beaconAddress) => getImplementationAddressFromBeacon(hre.network.provider, beaconAddress),
        },
    };
}
function makeUpgradesFunctions(hre) {
    return makeFunctions(hre, false);
}
function makeDefenderV1Functions(hre) {
    const { makeVerifyDeploy, makeVerifyDeployWithUploadedArtifact, makeGetVerifyDeployBuildInfo, makeGetVerifyDeployArtifact, makeGetBytecodeDigest, } = require('./defender-v1/verify-deployment');
    const { makeProposeUpgrade } = require('./defender-v1/propose-upgrade');
    return {
        proposeUpgrade: makeProposeUpgrade(hre),
        verifyDeployment: makeVerifyDeploy(hre),
        verifyDeploymentWithUploadedArtifact: makeVerifyDeployWithUploadedArtifact(hre),
        getDeploymentArtifact: makeGetVerifyDeployArtifact(hre),
        getDeploymentBuildInfo: makeGetVerifyDeployBuildInfo(hre),
        getBytecodeDigest: makeGetBytecodeDigest(hre),
    };
}
function makeDefenderFunctions(hre) {
    const { makeDeployContract } = require('./deploy-contract');
    const { makeProposeUpgradeWithApproval } = require('./defender/propose-upgrade-with-approval');
    const { makeGetDeployApprovalProcess, makeGetUpgradeApprovalProcess } = require('./defender/get-approval-process');
    const getUpgradeApprovalProcess = makeGetUpgradeApprovalProcess(hre);
    return {
        ...makeFunctions(hre, true),
        ...makeDefenderV1Functions(hre),
        deployContract: makeDeployContract(hre, true),
        proposeUpgradeWithApproval: makeProposeUpgradeWithApproval(hre, true),
        getDeployApprovalProcess: makeGetDeployApprovalProcess(hre),
        getUpgradeApprovalProcess: getUpgradeApprovalProcess,
        getDefaultApprovalProcess: getUpgradeApprovalProcess, // deprecated, is an alias for getUpgradeApprovalProcess
    };
}
function tryRequire(id, resolveOnly) {
    try {
        resolveOnly ? require.resolve(id) : require(id);
        return true;
    }
    catch (e) {
        // do nothing
    }
    return false;
}
//# sourceMappingURL=index.js.map