"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeUpgradeProxy = void 0;
const debug_1 = __importDefault(require("./utils/debug"));
const upgrades_core_1 = require("@openzeppelin/upgrades-core");
const utils_1 = require("./utils");
const utils_2 = require("./defender/utils");
const ethers_1 = require("./utils/ethers");
const attach_abi_1 = require("./utils/attach-abi");
function makeUpgradeProxy(hre, defenderModule, log = debug_1.default) {
    return async function upgradeProxy(proxy, ImplFactory, opts = {}) {
        (0, utils_2.disableDefender)(hre, defenderModule, opts, upgradeProxy.name);
        const proxyAddress = await (0, utils_1.getContractAddress)(proxy);
        const { impl: nextImpl } = await (0, utils_1.deployProxyImpl)(hre, ImplFactory, opts, proxyAddress);
        // upgrade kind is inferred above
        const upgradeTo = await getUpgrader(proxyAddress, opts, (0, utils_1.getSigner)(ImplFactory.runner));
        const call = encodeCall(ImplFactory, opts.call);
        const upgradeTx = await upgradeTo(nextImpl, call);
        const inst = (0, ethers_1.attach)(ImplFactory, proxyAddress);
        // @ts-ignore Won't be readonly because inst was created through attach.
        inst.deployTransaction = upgradeTx;
        return inst;
    };
    async function getUpgrader(proxyAddress, opts, signer) {
        const { provider } = hre.network;
        const adminAddress = await (0, upgrades_core_1.getAdminAddress)(provider, proxyAddress);
        const adminBytecode = await (0, upgrades_core_1.getCode)(provider, adminAddress);
        const overrides = opts.txOverrides ? [opts.txOverrides] : [];
        if ((0, upgrades_core_1.isEmptySlot)(adminAddress) || adminBytecode === '0x') {
            // No admin contract: use ITransparentUpgradeableProxy to get proxiable interface
            const upgradeInterfaceVersion = await (0, upgrades_core_1.getUpgradeInterfaceVersion)(provider, proxyAddress, log);
            switch (upgradeInterfaceVersion) {
                case '5.0.0': {
                    const proxy = await (0, attach_abi_1.attachITransparentUpgradeableProxyV5)(hre, proxyAddress, signer);
                    return (nextImpl, call) => proxy.upgradeToAndCall(nextImpl, call ?? '0x', ...overrides);
                }
                default: {
                    if (upgradeInterfaceVersion !== undefined) {
                        // Log as debug if the interface version is an unknown string.
                        // Do not throw an error because this could be caused by a fallback function.
                        log(`Unknown UPGRADE_INTERFACE_VERSION ${upgradeInterfaceVersion} for proxy at ${proxyAddress}. Expected 5.0.0`);
                    }
                    const proxy = await (0, attach_abi_1.attachITransparentUpgradeableProxyV4)(hre, proxyAddress, signer);
                    return (nextImpl, call) => call ? proxy.upgradeToAndCall(nextImpl, call, ...overrides) : proxy.upgradeTo(nextImpl, ...overrides);
                }
            }
        }
        else {
            // Admin contract: redirect upgrade call through it
            const upgradeInterfaceVersion = await (0, upgrades_core_1.getUpgradeInterfaceVersion)(provider, adminAddress, log);
            switch (upgradeInterfaceVersion) {
                case '5.0.0': {
                    const admin = await (0, attach_abi_1.attachProxyAdminV5)(hre, adminAddress, signer);
                    return (nextImpl, call) => admin.upgradeAndCall(proxyAddress, nextImpl, call ?? '0x', ...overrides);
                }
                default: {
                    if (upgradeInterfaceVersion !== undefined) {
                        // Log as debug if the interface version is an unknown string.
                        // Do not throw an error because this could be caused by a fallback function.
                        log(`Unknown UPGRADE_INTERFACE_VERSION ${upgradeInterfaceVersion} for proxy admin at ${adminAddress}. Expected 5.0.0`);
                    }
                    const admin = await (0, attach_abi_1.attachProxyAdminV4)(hre, adminAddress, signer);
                    return (nextImpl, call) => call
                        ? admin.upgradeAndCall(proxyAddress, nextImpl, call, ...overrides)
                        : admin.upgrade(proxyAddress, nextImpl, ...overrides);
                }
            }
        }
    }
}
exports.makeUpgradeProxy = makeUpgradeProxy;
function encodeCall(factory, call) {
    if (!call) {
        return undefined;
    }
    if (typeof call === 'string') {
        call = { fn: call };
    }
    return factory.interface.encodeFunctionData(call.fn, call.args ?? []);
}
//# sourceMappingURL=upgrade-proxy.js.map