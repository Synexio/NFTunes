"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeProposeUpgrade = void 0;
require("../type-extensions");
const upgrades_core_1 = require("@openzeppelin/upgrades-core");
const ethers_1 = require("ethers");
const utils_1 = require("./utils");
function makeProposeUpgrade(hre) {
    return async function proposeUpgrade(proxyAddress, contractNameOrImplFactory, opts = {}) {
        const client = (0, utils_1.getAdminClient)(hre);
        const network = await (0, utils_1.getNetwork)(hre);
        const { title, description, proxyAdmin, multisig, multisigType, ...moreOpts } = opts;
        if (await (0, upgrades_core_1.isBeaconProxy)(hre.network.provider, proxyAddress)) {
            throw new Error(`Beacon proxy is not currently supported with defender.proposeUpgrade()`);
        }
        else if (!multisig &&
            (await (0, upgrades_core_1.isTransparentOrUUPSProxy)(hre.network.provider, proxyAddress)) &&
            !(await (0, upgrades_core_1.isTransparentProxy)(hre.network.provider, proxyAddress))) {
            throw new Error(`Multisig address is a required property for UUPS proxies`);
        }
        else {
            // try getting the implementation address so that it will give an error if it's not a transparent/uups proxy
            await (0, upgrades_core_1.getImplementationAddress)(hre.network.provider, proxyAddress);
        }
        const implFactory = typeof contractNameOrImplFactory === 'string'
            ? await hre.ethers.getContractFactory(contractNameOrImplFactory)
            : contractNameOrImplFactory;
        const contractName = typeof contractNameOrImplFactory === 'string' ? contractNameOrImplFactory : undefined;
        const contract = { address: proxyAddress, network, abi: implFactory.interface.formatJson() };
        const prepareUpgradeResult = await hre.upgrades.prepareUpgrade(proxyAddress, implFactory, {
            getTxResponse: true,
            ...moreOpts,
        });
        let txResponse, newImplementation;
        if (typeof prepareUpgradeResult === 'string') {
            newImplementation = prepareUpgradeResult;
        }
        else {
            txResponse = prepareUpgradeResult;
            newImplementation = (0, ethers_1.getCreateAddress)(txResponse);
        }
        const verificationResponse = contractName && opts.bytecodeVerificationReferenceUrl
            ? await hre.defender.verifyDeployment(newImplementation, contractName, opts.bytecodeVerificationReferenceUrl)
            : undefined;
        const proposalResponse = await client.proposeUpgrade({
            newImplementation,
            title,
            description,
            proxyAdmin,
            via: multisig,
            viaType: multisigType,
        }, contract);
        return {
            ...proposalResponse,
            txResponse,
            verificationResponse,
        };
    };
}
exports.makeProposeUpgrade = makeProposeUpgrade;
//# sourceMappingURL=propose-upgrade.js.map