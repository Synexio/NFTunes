"use strict";
// This file is generated automatically by infrastructure scripts. Please don't edit by hand.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MappingType = exports.FunctionType = exports.ArrayTypeName = exports.ErrorParameter = exports.ErrorParametersDeclaration = exports.ErrorDefinition = exports.UserDefinedValueTypeDefinition = exports.EventParameter = exports.EventParametersDeclaration = exports.EventDefinition = exports.ModifierInvocation = exports.ModifierDefinition = exports.ReceiveFunctionDefinition = exports.FallbackFunctionDefinition = exports.UnnamedFunctionDefinition = exports.ConstructorDefinition = exports.ReturnsDeclaration = exports.OverridePathsDeclaration = exports.OverrideSpecifier = exports.Parameter = exports.ParametersDeclaration = exports.FunctionDefinition = exports.StateVariableDefinitionValue = exports.StateVariableDefinition = exports.ConstantDefinition = exports.EnumDefinition = exports.StructMember = exports.StructDefinition = exports.LibraryDefinition = exports.InterfaceDefinition = exports.InheritanceType = exports.InheritanceSpecifier = exports.ContractDefinition = exports.UsingAlias = exports.UsingDeconstructionSymbol = exports.UsingDeconstruction = exports.UsingDirective = exports.ImportAlias = exports.ImportDeconstructionSymbol = exports.ImportDeconstruction = exports.NamedImport = exports.PathImport = exports.ImportDirective = exports.VersionComparator = exports.VersionRange = exports.VersionPragma = exports.ExperimentalPragma = exports.ABICoderPragma = exports.PragmaDirective = exports.SourceUnit = void 0;
exports.NamedArgumentsDeclaration = exports.PositionalArgumentsDeclaration = exports.IndexAccessEnd = exports.IndexAccessExpression = exports.MemberAccessExpression = exports.CallOptionsExpression = exports.FunctionCallExpression = exports.PrefixExpression = exports.PostfixExpression = exports.ExponentiationExpression = exports.MultiplicativeExpression = exports.AdditiveExpression = exports.ShiftExpression = exports.BitwiseAndExpression = exports.BitwiseXorExpression = exports.BitwiseOrExpression = exports.ComparisonExpression = exports.EqualityExpression = exports.AndExpression = exports.OrExpression = exports.ConditionalExpression = exports.AssignmentExpression = exports.ThrowStatement = exports.RevertStatement = exports.CatchClauseError = exports.CatchClause = exports.TryStatement = exports.EmitStatement = exports.ReturnStatement = exports.BreakStatement = exports.ContinueStatement = exports.DoWhileStatement = exports.WhileStatement = exports.ForStatement = exports.ElseBranch = exports.IfStatement = exports.VariableDeclarationValue = exports.VariableDeclarationStatement = exports.UntypedTupleMember = exports.TypedTupleMember = exports.TupleDeconstructionElement = exports.TupleDeconstructionStatement = exports.AssemblyFlagsDeclaration = exports.AssemblyStatement = exports.ExpressionStatement = exports.UncheckedBlock = exports.Block = exports.AddressType = exports.MappingValue = exports.MappingKey = void 0;
exports.ElementaryType = exports.MappingKeyType = exports.FunctionTypeAttribute = exports.TypeName = exports.ModifierAttribute = exports.ReceiveFunctionAttribute = exports.FallbackFunctionAttribute = exports.UnnamedFunctionAttribute = exports.ConstructorAttribute = exports.FunctionBody = exports.FunctionAttribute = exports.FunctionName = exports.StateVariableAttribute = exports.ContractMember = exports.UsingTarget = exports.UsingOperator = exports.UsingClause = exports.ImportClause = exports.VersionExpression = exports.ExperimentalFeature = exports.Pragma = exports.SourceUnitMember = exports.YulFunctionCallExpression = exports.YulLabel = exports.YulContinueStatement = exports.YulBreakStatement = exports.YulLeaveStatement = exports.YulValueCase = exports.YulDefaultCase = exports.YulSwitchStatement = exports.YulForStatement = exports.YulIfStatement = exports.YulColonEqual = exports.YulStackAssignmentStatement = exports.YulVariableAssignmentStatement = exports.YulVariableDeclarationValue = exports.YulVariableDeclarationStatement = exports.YulReturnsDeclaration = exports.YulParametersDeclaration = exports.YulFunctionDefinition = exports.YulBlock = exports.DecimalNumberExpression = exports.HexNumberExpression = exports.ArrayExpression = exports.TupleValue = exports.TupleExpression = exports.NewExpression = exports.TypeExpression = exports.NamedArgument = exports.NamedArgumentGroup = void 0;
exports.OverridePaths = exports.Parameters = exports.EnumMembers = exports.InheritanceTypes = exports.UsingDeconstructionSymbols = exports.ImportDeconstructionSymbols = exports.VersionSpecifiers = exports.VersionExpressionSets = exports.YulSwitchCases = exports.YulStatements = exports.UnicodeStringLiterals = exports.HexStringLiterals = exports.StringLiterals = exports.CatchClauses = exports.Statements = exports.FunctionTypeAttributes = exports.ModifierAttributes = exports.ReceiveFunctionAttributes = exports.FallbackFunctionAttributes = exports.UnnamedFunctionAttributes = exports.ConstructorAttributes = exports.FunctionAttributes = exports.StateVariableAttributes = exports.StructMembers = exports.LibraryMembers = exports.InterfaceMembers = exports.ContractMembers = exports.VersionExpressionSet = exports.SourceUnitMembers = exports.YulLiteral = exports.YulBuiltInFunction = exports.YulPathComponent = exports.YulExpression = exports.YulSwitchCase = exports.YulAssignmentOperator = exports.YulStatement = exports.UnicodeStringLiteral = exports.HexStringLiteral = exports.StringLiteral = exports.StringExpression = exports.NumberUnit = exports.ArgumentsDeclaration = exports.MemberAccess = exports.Expression = exports.ForStatementCondition = exports.ForStatementInitialization = exports.StorageLocation = exports.VariableDeclarationType = exports.TupleMember = exports.Statement = void 0;
exports.YulPath = exports.YulPaths = exports.YulArguments = exports.YulReturnVariables = exports.YulParameters = exports.IdentifierPath = exports.ArrayValues = exports.TupleValues = exports.CallOptions = exports.NamedArguments = exports.PositionalArguments = exports.TupleDeconstructionElements = exports.AssemblyFlags = exports.ErrorParameters = exports.EventParameters = void 0;
const assert = __importStar(require("node:assert"));
const generated_1 = require("../../napi-bindings/generated");
const cst_1 = require("../../cst");
const kinds_1 = require("../../kinds");
/*
 * Sequences:
 */
class SourceUnit {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$members] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                members: new SourceUnitMembers($members),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.SourceUnit);
    }
    get members() {
        return this.fetch().members;
    }
}
exports.SourceUnit = SourceUnit;
class PragmaDirective {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$pragmaKeyword, $pragma, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                pragmaKeyword: $pragmaKeyword,
                pragma: new Pragma($pragma),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.PragmaDirective);
    }
    get pragmaKeyword() {
        return this.fetch().pragmaKeyword;
    }
    get pragma() {
        return this.fetch().pragma;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.PragmaDirective = PragmaDirective;
class ABICoderPragma {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$abicoderKeyword, $version] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                abicoderKeyword: $abicoderKeyword,
                version: $version,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ABICoderPragma);
    }
    get abicoderKeyword() {
        return this.fetch().abicoderKeyword;
    }
    get version() {
        return this.fetch().version;
    }
}
exports.ABICoderPragma = ABICoderPragma;
class ExperimentalPragma {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$experimentalKeyword, $feature] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                experimentalKeyword: $experimentalKeyword,
                feature: new ExperimentalFeature($feature),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ExperimentalPragma);
    }
    get experimentalKeyword() {
        return this.fetch().experimentalKeyword;
    }
    get feature() {
        return this.fetch().feature;
    }
}
exports.ExperimentalPragma = ExperimentalPragma;
class VersionPragma {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$solidityKeyword, $sets] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                solidityKeyword: $solidityKeyword,
                sets: new VersionExpressionSets($sets),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.VersionPragma);
    }
    get solidityKeyword() {
        return this.fetch().solidityKeyword;
    }
    get sets() {
        return this.fetch().sets;
    }
}
exports.VersionPragma = VersionPragma;
class VersionRange {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                leftOperand: new VersionExpression($leftOperand),
                operator: $operator,
                rightOperand: new VersionExpression($rightOperand),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.VersionRange);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
exports.VersionRange = VersionRange;
class VersionComparator {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operator, $operand] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                operator: $operator,
                operand: new VersionExpression($operand),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.VersionComparator);
    }
    get operator() {
        return this.fetch().operator;
    }
    get operand() {
        return this.fetch().operand;
    }
}
exports.VersionComparator = VersionComparator;
class ImportDirective {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$importKeyword, $clause, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                importKeyword: $importKeyword,
                clause: new ImportClause($clause),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ImportDirective);
    }
    get importKeyword() {
        return this.fetch().importKeyword;
    }
    get clause() {
        return this.fetch().clause;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.ImportDirective = ImportDirective;
class PathImport {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$path, $alias] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                path: new StringLiteral($path),
                alias: $alias === null ? undefined : new ImportAlias($alias),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.PathImport);
    }
    get path() {
        return this.fetch().path;
    }
    get alias() {
        return this.fetch().alias;
    }
}
exports.PathImport = PathImport;
class NamedImport {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$asterisk, $alias, $fromKeyword, $path] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                asterisk: $asterisk,
                alias: new ImportAlias($alias),
                fromKeyword: $fromKeyword,
                path: new StringLiteral($path),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.NamedImport);
    }
    get asterisk() {
        return this.fetch().asterisk;
    }
    get alias() {
        return this.fetch().alias;
    }
    get fromKeyword() {
        return this.fetch().fromKeyword;
    }
    get path() {
        return this.fetch().path;
    }
}
exports.NamedImport = NamedImport;
class ImportDeconstruction {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openBrace, $symbols, $closeBrace, $fromKeyword, $path] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                openBrace: $openBrace,
                symbols: new ImportDeconstructionSymbols($symbols),
                closeBrace: $closeBrace,
                fromKeyword: $fromKeyword,
                path: new StringLiteral($path),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ImportDeconstruction);
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get symbols() {
        return this.fetch().symbols;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
    get fromKeyword() {
        return this.fetch().fromKeyword;
    }
    get path() {
        return this.fetch().path;
    }
}
exports.ImportDeconstruction = ImportDeconstruction;
class ImportDeconstructionSymbol {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$name, $alias] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                name: $name,
                alias: $alias === null ? undefined : new ImportAlias($alias),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ImportDeconstructionSymbol);
    }
    get name() {
        return this.fetch().name;
    }
    get alias() {
        return this.fetch().alias;
    }
}
exports.ImportDeconstructionSymbol = ImportDeconstructionSymbol;
class ImportAlias {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$asKeyword, $identifier] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                asKeyword: $asKeyword,
                identifier: $identifier,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ImportAlias);
    }
    get asKeyword() {
        return this.fetch().asKeyword;
    }
    get identifier() {
        return this.fetch().identifier;
    }
}
exports.ImportAlias = ImportAlias;
class UsingDirective {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$usingKeyword, $clause, $forKeyword, $target, $globalKeyword, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                usingKeyword: $usingKeyword,
                clause: new UsingClause($clause),
                forKeyword: $forKeyword,
                target: new UsingTarget($target),
                globalKeyword: $globalKeyword === null ? undefined : $globalKeyword,
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.UsingDirective);
    }
    get usingKeyword() {
        return this.fetch().usingKeyword;
    }
    get clause() {
        return this.fetch().clause;
    }
    get forKeyword() {
        return this.fetch().forKeyword;
    }
    get target() {
        return this.fetch().target;
    }
    get globalKeyword() {
        return this.fetch().globalKeyword;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.UsingDirective = UsingDirective;
class UsingDeconstruction {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openBrace, $symbols, $closeBrace] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                openBrace: $openBrace,
                symbols: new UsingDeconstructionSymbols($symbols),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.UsingDeconstruction);
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get symbols() {
        return this.fetch().symbols;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
exports.UsingDeconstruction = UsingDeconstruction;
class UsingDeconstructionSymbol {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$name, $alias] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                name: new IdentifierPath($name),
                alias: $alias === null ? undefined : new UsingAlias($alias),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.UsingDeconstructionSymbol);
    }
    get name() {
        return this.fetch().name;
    }
    get alias() {
        return this.fetch().alias;
    }
}
exports.UsingDeconstructionSymbol = UsingDeconstructionSymbol;
class UsingAlias {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$asKeyword, $operator] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                asKeyword: $asKeyword,
                operator: new UsingOperator($operator),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.UsingAlias);
    }
    get asKeyword() {
        return this.fetch().asKeyword;
    }
    get operator() {
        return this.fetch().operator;
    }
}
exports.UsingAlias = UsingAlias;
class ContractDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$abstractKeyword, $contractKeyword, $name, $inheritance, $openBrace, $members, $closeBrace] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                abstractKeyword: $abstractKeyword === null ? undefined : $abstractKeyword,
                contractKeyword: $contractKeyword,
                name: $name,
                inheritance: $inheritance === null ? undefined : new InheritanceSpecifier($inheritance),
                openBrace: $openBrace,
                members: new ContractMembers($members),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ContractDefinition);
    }
    get abstractKeyword() {
        return this.fetch().abstractKeyword;
    }
    get contractKeyword() {
        return this.fetch().contractKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get inheritance() {
        return this.fetch().inheritance;
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get members() {
        return this.fetch().members;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
exports.ContractDefinition = ContractDefinition;
class InheritanceSpecifier {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$isKeyword, $types] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                isKeyword: $isKeyword,
                types: new InheritanceTypes($types),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.InheritanceSpecifier);
    }
    get isKeyword() {
        return this.fetch().isKeyword;
    }
    get types() {
        return this.fetch().types;
    }
}
exports.InheritanceSpecifier = InheritanceSpecifier;
class InheritanceType {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $arguments] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                typeName: new IdentifierPath($typeName),
                arguments: $arguments === null ? undefined : new ArgumentsDeclaration($arguments),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.InheritanceType);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get arguments() {
        return this.fetch().arguments;
    }
}
exports.InheritanceType = InheritanceType;
class InterfaceDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$interfaceKeyword, $name, $inheritance, $openBrace, $members, $closeBrace] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                interfaceKeyword: $interfaceKeyword,
                name: $name,
                inheritance: $inheritance === null ? undefined : new InheritanceSpecifier($inheritance),
                openBrace: $openBrace,
                members: new InterfaceMembers($members),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.InterfaceDefinition);
    }
    get interfaceKeyword() {
        return this.fetch().interfaceKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get inheritance() {
        return this.fetch().inheritance;
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get members() {
        return this.fetch().members;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
exports.InterfaceDefinition = InterfaceDefinition;
class LibraryDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$libraryKeyword, $name, $openBrace, $members, $closeBrace] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                libraryKeyword: $libraryKeyword,
                name: $name,
                openBrace: $openBrace,
                members: new LibraryMembers($members),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.LibraryDefinition);
    }
    get libraryKeyword() {
        return this.fetch().libraryKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get members() {
        return this.fetch().members;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
exports.LibraryDefinition = LibraryDefinition;
class StructDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$structKeyword, $name, $openBrace, $members, $closeBrace] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                structKeyword: $structKeyword,
                name: $name,
                openBrace: $openBrace,
                members: new StructMembers($members),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.StructDefinition);
    }
    get structKeyword() {
        return this.fetch().structKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get members() {
        return this.fetch().members;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
exports.StructDefinition = StructDefinition;
class StructMember {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $name, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                typeName: new TypeName($typeName),
                name: $name,
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.StructMember);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get name() {
        return this.fetch().name;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.StructMember = StructMember;
class EnumDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$enumKeyword, $name, $openBrace, $members, $closeBrace] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                enumKeyword: $enumKeyword,
                name: $name,
                openBrace: $openBrace,
                members: new EnumMembers($members),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.EnumDefinition);
    }
    get enumKeyword() {
        return this.fetch().enumKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get members() {
        return this.fetch().members;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
exports.EnumDefinition = EnumDefinition;
class ConstantDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $constantKeyword, $name, $equal, $value, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                typeName: new TypeName($typeName),
                constantKeyword: $constantKeyword,
                name: $name,
                equal: $equal,
                value: new Expression($value),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ConstantDefinition);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get constantKeyword() {
        return this.fetch().constantKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get equal() {
        return this.fetch().equal;
    }
    get value() {
        return this.fetch().value;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.ConstantDefinition = ConstantDefinition;
class StateVariableDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $attributes, $name, $value, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                typeName: new TypeName($typeName),
                attributes: new StateVariableAttributes($attributes),
                name: $name,
                value: $value === null ? undefined : new StateVariableDefinitionValue($value),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.StateVariableDefinition);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get attributes() {
        return this.fetch().attributes;
    }
    get name() {
        return this.fetch().name;
    }
    get value() {
        return this.fetch().value;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.StateVariableDefinition = StateVariableDefinition;
class StateVariableDefinitionValue {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$equal, $value] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                equal: $equal,
                value: new Expression($value),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.StateVariableDefinitionValue);
    }
    get equal() {
        return this.fetch().equal;
    }
    get value() {
        return this.fetch().value;
    }
}
exports.StateVariableDefinitionValue = StateVariableDefinitionValue;
class FunctionDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$functionKeyword, $name, $parameters, $attributes, $returns, $body] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                functionKeyword: $functionKeyword,
                name: new FunctionName($name),
                parameters: new ParametersDeclaration($parameters),
                attributes: new FunctionAttributes($attributes),
                returns: $returns === null ? undefined : new ReturnsDeclaration($returns),
                body: new FunctionBody($body),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.FunctionDefinition);
    }
    get functionKeyword() {
        return this.fetch().functionKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get attributes() {
        return this.fetch().attributes;
    }
    get returns() {
        return this.fetch().returns;
    }
    get body() {
        return this.fetch().body;
    }
}
exports.FunctionDefinition = FunctionDefinition;
class ParametersDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $parameters, $closeParen] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                openParen: $openParen,
                parameters: new Parameters($parameters),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ParametersDeclaration);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
exports.ParametersDeclaration = ParametersDeclaration;
class Parameter {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $storageLocation, $name] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                typeName: new TypeName($typeName),
                storageLocation: $storageLocation === null ? undefined : new StorageLocation($storageLocation),
                name: $name === null ? undefined : $name,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.Parameter);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get storageLocation() {
        return this.fetch().storageLocation;
    }
    get name() {
        return this.fetch().name;
    }
}
exports.Parameter = Parameter;
class OverrideSpecifier {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$overrideKeyword, $overridden] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                overrideKeyword: $overrideKeyword,
                overridden: $overridden === null ? undefined : new OverridePathsDeclaration($overridden),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.OverrideSpecifier);
    }
    get overrideKeyword() {
        return this.fetch().overrideKeyword;
    }
    get overridden() {
        return this.fetch().overridden;
    }
}
exports.OverrideSpecifier = OverrideSpecifier;
class OverridePathsDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $paths, $closeParen] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                openParen: $openParen,
                paths: new OverridePaths($paths),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.OverridePathsDeclaration);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get paths() {
        return this.fetch().paths;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
exports.OverridePathsDeclaration = OverridePathsDeclaration;
class ReturnsDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$returnsKeyword, $variables] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                returnsKeyword: $returnsKeyword,
                variables: new ParametersDeclaration($variables),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ReturnsDeclaration);
    }
    get returnsKeyword() {
        return this.fetch().returnsKeyword;
    }
    get variables() {
        return this.fetch().variables;
    }
}
exports.ReturnsDeclaration = ReturnsDeclaration;
class ConstructorDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$constructorKeyword, $parameters, $attributes, $body] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                constructorKeyword: $constructorKeyword,
                parameters: new ParametersDeclaration($parameters),
                attributes: new ConstructorAttributes($attributes),
                body: new Block($body),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ConstructorDefinition);
    }
    get constructorKeyword() {
        return this.fetch().constructorKeyword;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get attributes() {
        return this.fetch().attributes;
    }
    get body() {
        return this.fetch().body;
    }
}
exports.ConstructorDefinition = ConstructorDefinition;
class UnnamedFunctionDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$functionKeyword, $parameters, $attributes, $body] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                functionKeyword: $functionKeyword,
                parameters: new ParametersDeclaration($parameters),
                attributes: new UnnamedFunctionAttributes($attributes),
                body: new FunctionBody($body),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.UnnamedFunctionDefinition);
    }
    get functionKeyword() {
        return this.fetch().functionKeyword;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get attributes() {
        return this.fetch().attributes;
    }
    get body() {
        return this.fetch().body;
    }
}
exports.UnnamedFunctionDefinition = UnnamedFunctionDefinition;
class FallbackFunctionDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$fallbackKeyword, $parameters, $attributes, $returns, $body] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                fallbackKeyword: $fallbackKeyword,
                parameters: new ParametersDeclaration($parameters),
                attributes: new FallbackFunctionAttributes($attributes),
                returns: $returns === null ? undefined : new ReturnsDeclaration($returns),
                body: new FunctionBody($body),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.FallbackFunctionDefinition);
    }
    get fallbackKeyword() {
        return this.fetch().fallbackKeyword;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get attributes() {
        return this.fetch().attributes;
    }
    get returns() {
        return this.fetch().returns;
    }
    get body() {
        return this.fetch().body;
    }
}
exports.FallbackFunctionDefinition = FallbackFunctionDefinition;
class ReceiveFunctionDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$receiveKeyword, $parameters, $attributes, $body] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                receiveKeyword: $receiveKeyword,
                parameters: new ParametersDeclaration($parameters),
                attributes: new ReceiveFunctionAttributes($attributes),
                body: new FunctionBody($body),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ReceiveFunctionDefinition);
    }
    get receiveKeyword() {
        return this.fetch().receiveKeyword;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get attributes() {
        return this.fetch().attributes;
    }
    get body() {
        return this.fetch().body;
    }
}
exports.ReceiveFunctionDefinition = ReceiveFunctionDefinition;
class ModifierDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$modifierKeyword, $name, $parameters, $attributes, $body] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                modifierKeyword: $modifierKeyword,
                name: $name,
                parameters: $parameters === null ? undefined : new ParametersDeclaration($parameters),
                attributes: new ModifierAttributes($attributes),
                body: new FunctionBody($body),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ModifierDefinition);
    }
    get modifierKeyword() {
        return this.fetch().modifierKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get attributes() {
        return this.fetch().attributes;
    }
    get body() {
        return this.fetch().body;
    }
}
exports.ModifierDefinition = ModifierDefinition;
class ModifierInvocation {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$name, $arguments] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                name: new IdentifierPath($name),
                arguments: $arguments === null ? undefined : new ArgumentsDeclaration($arguments),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ModifierInvocation);
    }
    get name() {
        return this.fetch().name;
    }
    get arguments() {
        return this.fetch().arguments;
    }
}
exports.ModifierInvocation = ModifierInvocation;
class EventDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$eventKeyword, $name, $parameters, $anonymousKeyword, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                eventKeyword: $eventKeyword,
                name: $name,
                parameters: new EventParametersDeclaration($parameters),
                anonymousKeyword: $anonymousKeyword === null ? undefined : $anonymousKeyword,
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.EventDefinition);
    }
    get eventKeyword() {
        return this.fetch().eventKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get anonymousKeyword() {
        return this.fetch().anonymousKeyword;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.EventDefinition = EventDefinition;
class EventParametersDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $parameters, $closeParen] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                openParen: $openParen,
                parameters: new EventParameters($parameters),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.EventParametersDeclaration);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
exports.EventParametersDeclaration = EventParametersDeclaration;
class EventParameter {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $indexedKeyword, $name] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                typeName: new TypeName($typeName),
                indexedKeyword: $indexedKeyword === null ? undefined : $indexedKeyword,
                name: $name === null ? undefined : $name,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.EventParameter);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get indexedKeyword() {
        return this.fetch().indexedKeyword;
    }
    get name() {
        return this.fetch().name;
    }
}
exports.EventParameter = EventParameter;
class UserDefinedValueTypeDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeKeyword, $name, $isKeyword, $valueType, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                typeKeyword: $typeKeyword,
                name: $name,
                isKeyword: $isKeyword,
                valueType: new ElementaryType($valueType),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.UserDefinedValueTypeDefinition);
    }
    get typeKeyword() {
        return this.fetch().typeKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get isKeyword() {
        return this.fetch().isKeyword;
    }
    get valueType() {
        return this.fetch().valueType;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.UserDefinedValueTypeDefinition = UserDefinedValueTypeDefinition;
class ErrorDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$errorKeyword, $name, $members, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                errorKeyword: $errorKeyword,
                name: $name,
                members: new ErrorParametersDeclaration($members),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ErrorDefinition);
    }
    get errorKeyword() {
        return this.fetch().errorKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get members() {
        return this.fetch().members;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.ErrorDefinition = ErrorDefinition;
class ErrorParametersDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $parameters, $closeParen] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                openParen: $openParen,
                parameters: new ErrorParameters($parameters),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ErrorParametersDeclaration);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
exports.ErrorParametersDeclaration = ErrorParametersDeclaration;
class ErrorParameter {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $name] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                typeName: new TypeName($typeName),
                name: $name === null ? undefined : $name,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ErrorParameter);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get name() {
        return this.fetch().name;
    }
}
exports.ErrorParameter = ErrorParameter;
class ArrayTypeName {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operand, $openBracket, $index, $closeBracket] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                operand: new TypeName($operand),
                openBracket: $openBracket,
                index: $index === null ? undefined : new Expression($index),
                closeBracket: $closeBracket,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ArrayTypeName);
    }
    get operand() {
        return this.fetch().operand;
    }
    get openBracket() {
        return this.fetch().openBracket;
    }
    get index() {
        return this.fetch().index;
    }
    get closeBracket() {
        return this.fetch().closeBracket;
    }
}
exports.ArrayTypeName = ArrayTypeName;
class FunctionType {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$functionKeyword, $parameters, $attributes, $returns] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                functionKeyword: $functionKeyword,
                parameters: new ParametersDeclaration($parameters),
                attributes: new FunctionTypeAttributes($attributes),
                returns: $returns === null ? undefined : new ReturnsDeclaration($returns),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.FunctionType);
    }
    get functionKeyword() {
        return this.fetch().functionKeyword;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get attributes() {
        return this.fetch().attributes;
    }
    get returns() {
        return this.fetch().returns;
    }
}
exports.FunctionType = FunctionType;
class MappingType {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$mappingKeyword, $openParen, $keyType, $equalGreaterThan, $valueType, $closeParen] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                mappingKeyword: $mappingKeyword,
                openParen: $openParen,
                keyType: new MappingKey($keyType),
                equalGreaterThan: $equalGreaterThan,
                valueType: new MappingValue($valueType),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.MappingType);
    }
    get mappingKeyword() {
        return this.fetch().mappingKeyword;
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get keyType() {
        return this.fetch().keyType;
    }
    get equalGreaterThan() {
        return this.fetch().equalGreaterThan;
    }
    get valueType() {
        return this.fetch().valueType;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
exports.MappingType = MappingType;
class MappingKey {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$keyType, $name] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                keyType: new MappingKeyType($keyType),
                name: $name === null ? undefined : $name,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.MappingKey);
    }
    get keyType() {
        return this.fetch().keyType;
    }
    get name() {
        return this.fetch().name;
    }
}
exports.MappingKey = MappingKey;
class MappingValue {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $name] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                typeName: new TypeName($typeName),
                name: $name === null ? undefined : $name,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.MappingValue);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get name() {
        return this.fetch().name;
    }
}
exports.MappingValue = MappingValue;
class AddressType {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$addressKeyword, $payableKeyword] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                addressKeyword: $addressKeyword,
                payableKeyword: $payableKeyword === null ? undefined : $payableKeyword,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.AddressType);
    }
    get addressKeyword() {
        return this.fetch().addressKeyword;
    }
    get payableKeyword() {
        return this.fetch().payableKeyword;
    }
}
exports.AddressType = AddressType;
class Block {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openBrace, $statements, $closeBrace] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                openBrace: $openBrace,
                statements: new Statements($statements),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.Block);
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get statements() {
        return this.fetch().statements;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
exports.Block = Block;
class UncheckedBlock {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$uncheckedKeyword, $block] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                uncheckedKeyword: $uncheckedKeyword,
                block: new Block($block),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.UncheckedBlock);
    }
    get uncheckedKeyword() {
        return this.fetch().uncheckedKeyword;
    }
    get block() {
        return this.fetch().block;
    }
}
exports.UncheckedBlock = UncheckedBlock;
class ExpressionStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$expression, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                expression: new Expression($expression),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ExpressionStatement);
    }
    get expression() {
        return this.fetch().expression;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.ExpressionStatement = ExpressionStatement;
class AssemblyStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$assemblyKeyword, $label, $flags, $body] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                assemblyKeyword: $assemblyKeyword,
                label: $label === null ? undefined : new StringLiteral($label),
                flags: $flags === null ? undefined : new AssemblyFlagsDeclaration($flags),
                body: new YulBlock($body),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.AssemblyStatement);
    }
    get assemblyKeyword() {
        return this.fetch().assemblyKeyword;
    }
    get label() {
        return this.fetch().label;
    }
    get flags() {
        return this.fetch().flags;
    }
    get body() {
        return this.fetch().body;
    }
}
exports.AssemblyStatement = AssemblyStatement;
class AssemblyFlagsDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $flags, $closeParen] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                openParen: $openParen,
                flags: new AssemblyFlags($flags),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.AssemblyFlagsDeclaration);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get flags() {
        return this.fetch().flags;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
exports.AssemblyFlagsDeclaration = AssemblyFlagsDeclaration;
class TupleDeconstructionStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$varKeyword, $openParen, $elements, $closeParen, $equal, $expression, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                varKeyword: $varKeyword === null ? undefined : $varKeyword,
                openParen: $openParen,
                elements: new TupleDeconstructionElements($elements),
                closeParen: $closeParen,
                equal: $equal,
                expression: new Expression($expression),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.TupleDeconstructionStatement);
    }
    get varKeyword() {
        return this.fetch().varKeyword;
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get elements() {
        return this.fetch().elements;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
    get equal() {
        return this.fetch().equal;
    }
    get expression() {
        return this.fetch().expression;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.TupleDeconstructionStatement = TupleDeconstructionStatement;
class TupleDeconstructionElement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$member] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                member: $member === null ? undefined : new TupleMember($member),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.TupleDeconstructionElement);
    }
    get member() {
        return this.fetch().member;
    }
}
exports.TupleDeconstructionElement = TupleDeconstructionElement;
class TypedTupleMember {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $storageLocation, $name] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                typeName: new TypeName($typeName),
                storageLocation: $storageLocation === null ? undefined : new StorageLocation($storageLocation),
                name: $name,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.TypedTupleMember);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get storageLocation() {
        return this.fetch().storageLocation;
    }
    get name() {
        return this.fetch().name;
    }
}
exports.TypedTupleMember = TypedTupleMember;
class UntypedTupleMember {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$storageLocation, $name] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                storageLocation: $storageLocation === null ? undefined : new StorageLocation($storageLocation),
                name: $name,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.UntypedTupleMember);
    }
    get storageLocation() {
        return this.fetch().storageLocation;
    }
    get name() {
        return this.fetch().name;
    }
}
exports.UntypedTupleMember = UntypedTupleMember;
class VariableDeclarationStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$variableType, $storageLocation, $name, $value, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                variableType: new VariableDeclarationType($variableType),
                storageLocation: $storageLocation === null ? undefined : new StorageLocation($storageLocation),
                name: $name,
                value: $value === null ? undefined : new VariableDeclarationValue($value),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.VariableDeclarationStatement);
    }
    get variableType() {
        return this.fetch().variableType;
    }
    get storageLocation() {
        return this.fetch().storageLocation;
    }
    get name() {
        return this.fetch().name;
    }
    get value() {
        return this.fetch().value;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.VariableDeclarationStatement = VariableDeclarationStatement;
class VariableDeclarationValue {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$equal, $expression] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                equal: $equal,
                expression: new Expression($expression),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.VariableDeclarationValue);
    }
    get equal() {
        return this.fetch().equal;
    }
    get expression() {
        return this.fetch().expression;
    }
}
exports.VariableDeclarationValue = VariableDeclarationValue;
class IfStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$ifKeyword, $openParen, $condition, $closeParen, $body, $elseBranch] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                ifKeyword: $ifKeyword,
                openParen: $openParen,
                condition: new Expression($condition),
                closeParen: $closeParen,
                body: new Statement($body),
                elseBranch: $elseBranch === null ? undefined : new ElseBranch($elseBranch),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.IfStatement);
    }
    get ifKeyword() {
        return this.fetch().ifKeyword;
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get condition() {
        return this.fetch().condition;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
    get body() {
        return this.fetch().body;
    }
    get elseBranch() {
        return this.fetch().elseBranch;
    }
}
exports.IfStatement = IfStatement;
class ElseBranch {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$elseKeyword, $body] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                elseKeyword: $elseKeyword,
                body: new Statement($body),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ElseBranch);
    }
    get elseKeyword() {
        return this.fetch().elseKeyword;
    }
    get body() {
        return this.fetch().body;
    }
}
exports.ElseBranch = ElseBranch;
class ForStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$forKeyword, $openParen, $initialization, $condition, $iterator, $closeParen, $body] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                forKeyword: $forKeyword,
                openParen: $openParen,
                initialization: new ForStatementInitialization($initialization),
                condition: new ForStatementCondition($condition),
                iterator: $iterator === null ? undefined : new Expression($iterator),
                closeParen: $closeParen,
                body: new Statement($body),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ForStatement);
    }
    get forKeyword() {
        return this.fetch().forKeyword;
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get initialization() {
        return this.fetch().initialization;
    }
    get condition() {
        return this.fetch().condition;
    }
    get iterator() {
        return this.fetch().iterator;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
    get body() {
        return this.fetch().body;
    }
}
exports.ForStatement = ForStatement;
class WhileStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$whileKeyword, $openParen, $condition, $closeParen, $body] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                whileKeyword: $whileKeyword,
                openParen: $openParen,
                condition: new Expression($condition),
                closeParen: $closeParen,
                body: new Statement($body),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.WhileStatement);
    }
    get whileKeyword() {
        return this.fetch().whileKeyword;
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get condition() {
        return this.fetch().condition;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
    get body() {
        return this.fetch().body;
    }
}
exports.WhileStatement = WhileStatement;
class DoWhileStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$doKeyword, $body, $whileKeyword, $openParen, $condition, $closeParen, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                doKeyword: $doKeyword,
                body: new Statement($body),
                whileKeyword: $whileKeyword,
                openParen: $openParen,
                condition: new Expression($condition),
                closeParen: $closeParen,
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.DoWhileStatement);
    }
    get doKeyword() {
        return this.fetch().doKeyword;
    }
    get body() {
        return this.fetch().body;
    }
    get whileKeyword() {
        return this.fetch().whileKeyword;
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get condition() {
        return this.fetch().condition;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.DoWhileStatement = DoWhileStatement;
class ContinueStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$continueKeyword, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                continueKeyword: $continueKeyword,
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ContinueStatement);
    }
    get continueKeyword() {
        return this.fetch().continueKeyword;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.ContinueStatement = ContinueStatement;
class BreakStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$breakKeyword, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                breakKeyword: $breakKeyword,
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.BreakStatement);
    }
    get breakKeyword() {
        return this.fetch().breakKeyword;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.BreakStatement = BreakStatement;
class ReturnStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$returnKeyword, $expression, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                returnKeyword: $returnKeyword,
                expression: $expression === null ? undefined : new Expression($expression),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ReturnStatement);
    }
    get returnKeyword() {
        return this.fetch().returnKeyword;
    }
    get expression() {
        return this.fetch().expression;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.ReturnStatement = ReturnStatement;
class EmitStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$emitKeyword, $event, $arguments, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                emitKeyword: $emitKeyword,
                event: new IdentifierPath($event),
                arguments: new ArgumentsDeclaration($arguments),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.EmitStatement);
    }
    get emitKeyword() {
        return this.fetch().emitKeyword;
    }
    get event() {
        return this.fetch().event;
    }
    get arguments() {
        return this.fetch().arguments;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.EmitStatement = EmitStatement;
class TryStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$tryKeyword, $expression, $returns, $body, $catchClauses] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                tryKeyword: $tryKeyword,
                expression: new Expression($expression),
                returns: $returns === null ? undefined : new ReturnsDeclaration($returns),
                body: new Block($body),
                catchClauses: new CatchClauses($catchClauses),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.TryStatement);
    }
    get tryKeyword() {
        return this.fetch().tryKeyword;
    }
    get expression() {
        return this.fetch().expression;
    }
    get returns() {
        return this.fetch().returns;
    }
    get body() {
        return this.fetch().body;
    }
    get catchClauses() {
        return this.fetch().catchClauses;
    }
}
exports.TryStatement = TryStatement;
class CatchClause {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$catchKeyword, $error, $body] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                catchKeyword: $catchKeyword,
                error: $error === null ? undefined : new CatchClauseError($error),
                body: new Block($body),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.CatchClause);
    }
    get catchKeyword() {
        return this.fetch().catchKeyword;
    }
    get error() {
        return this.fetch().error;
    }
    get body() {
        return this.fetch().body;
    }
}
exports.CatchClause = CatchClause;
class CatchClauseError {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$name, $parameters] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                name: $name === null ? undefined : $name,
                parameters: new ParametersDeclaration($parameters),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.CatchClauseError);
    }
    get name() {
        return this.fetch().name;
    }
    get parameters() {
        return this.fetch().parameters;
    }
}
exports.CatchClauseError = CatchClauseError;
class RevertStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$revertKeyword, $error, $arguments, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                revertKeyword: $revertKeyword,
                error: $error === null ? undefined : new IdentifierPath($error),
                arguments: new ArgumentsDeclaration($arguments),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.RevertStatement);
    }
    get revertKeyword() {
        return this.fetch().revertKeyword;
    }
    get error() {
        return this.fetch().error;
    }
    get arguments() {
        return this.fetch().arguments;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.RevertStatement = RevertStatement;
class ThrowStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$throwKeyword, $semicolon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                throwKeyword: $throwKeyword,
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ThrowStatement);
    }
    get throwKeyword() {
        return this.fetch().throwKeyword;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
exports.ThrowStatement = ThrowStatement;
class AssignmentExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.AssignmentExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
exports.AssignmentExpression = AssignmentExpression;
class ConditionalExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operand, $questionMark, $trueExpression, $colon, $falseExpression] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                operand: new Expression($operand),
                questionMark: $questionMark,
                trueExpression: new Expression($trueExpression),
                colon: $colon,
                falseExpression: new Expression($falseExpression),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ConditionalExpression);
    }
    get operand() {
        return this.fetch().operand;
    }
    get questionMark() {
        return this.fetch().questionMark;
    }
    get trueExpression() {
        return this.fetch().trueExpression;
    }
    get colon() {
        return this.fetch().colon;
    }
    get falseExpression() {
        return this.fetch().falseExpression;
    }
}
exports.ConditionalExpression = ConditionalExpression;
class OrExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.OrExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
exports.OrExpression = OrExpression;
class AndExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.AndExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
exports.AndExpression = AndExpression;
class EqualityExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.EqualityExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
exports.EqualityExpression = EqualityExpression;
class ComparisonExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ComparisonExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
exports.ComparisonExpression = ComparisonExpression;
class BitwiseOrExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.BitwiseOrExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
exports.BitwiseOrExpression = BitwiseOrExpression;
class BitwiseXorExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.BitwiseXorExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
exports.BitwiseXorExpression = BitwiseXorExpression;
class BitwiseAndExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.BitwiseAndExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
exports.BitwiseAndExpression = BitwiseAndExpression;
class ShiftExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ShiftExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
exports.ShiftExpression = ShiftExpression;
class AdditiveExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.AdditiveExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
exports.AdditiveExpression = AdditiveExpression;
class MultiplicativeExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.MultiplicativeExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
exports.MultiplicativeExpression = MultiplicativeExpression;
class ExponentiationExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ExponentiationExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
exports.ExponentiationExpression = ExponentiationExpression;
class PostfixExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operand, $operator] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                operand: new Expression($operand),
                operator: $operator,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.PostfixExpression);
    }
    get operand() {
        return this.fetch().operand;
    }
    get operator() {
        return this.fetch().operator;
    }
}
exports.PostfixExpression = PostfixExpression;
class PrefixExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operator, $operand] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                operator: $operator,
                operand: new Expression($operand),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.PrefixExpression);
    }
    get operator() {
        return this.fetch().operator;
    }
    get operand() {
        return this.fetch().operand;
    }
}
exports.PrefixExpression = PrefixExpression;
class FunctionCallExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operand, $arguments] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                operand: new Expression($operand),
                arguments: new ArgumentsDeclaration($arguments),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.FunctionCallExpression);
    }
    get operand() {
        return this.fetch().operand;
    }
    get arguments() {
        return this.fetch().arguments;
    }
}
exports.FunctionCallExpression = FunctionCallExpression;
class CallOptionsExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operand, $openBrace, $options, $closeBrace] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                operand: new Expression($operand),
                openBrace: $openBrace,
                options: new CallOptions($options),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.CallOptionsExpression);
    }
    get operand() {
        return this.fetch().operand;
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get options() {
        return this.fetch().options;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
exports.CallOptionsExpression = CallOptionsExpression;
class MemberAccessExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operand, $period, $member] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                operand: new Expression($operand),
                period: $period,
                member: new MemberAccess($member),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.MemberAccessExpression);
    }
    get operand() {
        return this.fetch().operand;
    }
    get period() {
        return this.fetch().period;
    }
    get member() {
        return this.fetch().member;
    }
}
exports.MemberAccessExpression = MemberAccessExpression;
class IndexAccessExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operand, $openBracket, $start, $end, $closeBracket] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                operand: new Expression($operand),
                openBracket: $openBracket,
                start: $start === null ? undefined : new Expression($start),
                end: $end === null ? undefined : new IndexAccessEnd($end),
                closeBracket: $closeBracket,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.IndexAccessExpression);
    }
    get operand() {
        return this.fetch().operand;
    }
    get openBracket() {
        return this.fetch().openBracket;
    }
    get start() {
        return this.fetch().start;
    }
    get end() {
        return this.fetch().end;
    }
    get closeBracket() {
        return this.fetch().closeBracket;
    }
}
exports.IndexAccessExpression = IndexAccessExpression;
class IndexAccessEnd {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$colon, $end] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                colon: $colon,
                end: $end === null ? undefined : new Expression($end),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.IndexAccessEnd);
    }
    get colon() {
        return this.fetch().colon;
    }
    get end() {
        return this.fetch().end;
    }
}
exports.IndexAccessEnd = IndexAccessEnd;
class PositionalArgumentsDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $arguments, $closeParen] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                openParen: $openParen,
                arguments: new PositionalArguments($arguments),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.PositionalArgumentsDeclaration);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get arguments() {
        return this.fetch().arguments;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
exports.PositionalArgumentsDeclaration = PositionalArgumentsDeclaration;
class NamedArgumentsDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $arguments, $closeParen] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                openParen: $openParen,
                arguments: $arguments === null ? undefined : new NamedArgumentGroup($arguments),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.NamedArgumentsDeclaration);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get arguments() {
        return this.fetch().arguments;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
exports.NamedArgumentsDeclaration = NamedArgumentsDeclaration;
class NamedArgumentGroup {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openBrace, $arguments, $closeBrace] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                openBrace: $openBrace,
                arguments: new NamedArguments($arguments),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.NamedArgumentGroup);
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get arguments() {
        return this.fetch().arguments;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
exports.NamedArgumentGroup = NamedArgumentGroup;
class NamedArgument {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$name, $colon, $value] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                name: $name,
                colon: $colon,
                value: new Expression($value),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.NamedArgument);
    }
    get name() {
        return this.fetch().name;
    }
    get colon() {
        return this.fetch().colon;
    }
    get value() {
        return this.fetch().value;
    }
}
exports.NamedArgument = NamedArgument;
class TypeExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeKeyword, $openParen, $typeName, $closeParen] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                typeKeyword: $typeKeyword,
                openParen: $openParen,
                typeName: new TypeName($typeName),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.TypeExpression);
    }
    get typeKeyword() {
        return this.fetch().typeKeyword;
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
exports.TypeExpression = TypeExpression;
class NewExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$newKeyword, $typeName] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                newKeyword: $newKeyword,
                typeName: new TypeName($typeName),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.NewExpression);
    }
    get newKeyword() {
        return this.fetch().newKeyword;
    }
    get typeName() {
        return this.fetch().typeName;
    }
}
exports.NewExpression = NewExpression;
class TupleExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $items, $closeParen] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                openParen: $openParen,
                items: new TupleValues($items),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.TupleExpression);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get items() {
        return this.fetch().items;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
exports.TupleExpression = TupleExpression;
class TupleValue {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$expression] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                expression: $expression === null ? undefined : new Expression($expression),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.TupleValue);
    }
    get expression() {
        return this.fetch().expression;
    }
}
exports.TupleValue = TupleValue;
class ArrayExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openBracket, $items, $closeBracket] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                openBracket: $openBracket,
                items: new ArrayValues($items),
                closeBracket: $closeBracket,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ArrayExpression);
    }
    get openBracket() {
        return this.fetch().openBracket;
    }
    get items() {
        return this.fetch().items;
    }
    get closeBracket() {
        return this.fetch().closeBracket;
    }
}
exports.ArrayExpression = ArrayExpression;
class HexNumberExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$literal, $unit] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                literal: $literal,
                unit: $unit === null ? undefined : new NumberUnit($unit),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.HexNumberExpression);
    }
    get literal() {
        return this.fetch().literal;
    }
    get unit() {
        return this.fetch().unit;
    }
}
exports.HexNumberExpression = HexNumberExpression;
class DecimalNumberExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$literal, $unit] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                literal: $literal,
                unit: $unit === null ? undefined : new NumberUnit($unit),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.DecimalNumberExpression);
    }
    get literal() {
        return this.fetch().literal;
    }
    get unit() {
        return this.fetch().unit;
    }
}
exports.DecimalNumberExpression = DecimalNumberExpression;
class YulBlock {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openBrace, $statements, $closeBrace] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                openBrace: $openBrace,
                statements: new YulStatements($statements),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulBlock);
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get statements() {
        return this.fetch().statements;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
exports.YulBlock = YulBlock;
class YulFunctionDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$functionKeyword, $name, $parameters, $returns, $body] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                functionKeyword: $functionKeyword,
                name: $name,
                parameters: new YulParametersDeclaration($parameters),
                returns: $returns === null ? undefined : new YulReturnsDeclaration($returns),
                body: new YulBlock($body),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulFunctionDefinition);
    }
    get functionKeyword() {
        return this.fetch().functionKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get returns() {
        return this.fetch().returns;
    }
    get body() {
        return this.fetch().body;
    }
}
exports.YulFunctionDefinition = YulFunctionDefinition;
class YulParametersDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $parameters, $closeParen] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                openParen: $openParen,
                parameters: new YulParameters($parameters),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulParametersDeclaration);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
exports.YulParametersDeclaration = YulParametersDeclaration;
class YulReturnsDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$minusGreaterThan, $variables] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                minusGreaterThan: $minusGreaterThan,
                variables: new YulReturnVariables($variables),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulReturnsDeclaration);
    }
    get minusGreaterThan() {
        return this.fetch().minusGreaterThan;
    }
    get variables() {
        return this.fetch().variables;
    }
}
exports.YulReturnsDeclaration = YulReturnsDeclaration;
class YulVariableDeclarationStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$letKeyword, $names, $value] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                letKeyword: $letKeyword,
                names: $names,
                value: $value === null ? undefined : new YulVariableDeclarationValue($value),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulVariableDeclarationStatement);
    }
    get letKeyword() {
        return this.fetch().letKeyword;
    }
    get names() {
        return this.fetch().names;
    }
    get value() {
        return this.fetch().value;
    }
}
exports.YulVariableDeclarationStatement = YulVariableDeclarationStatement;
class YulVariableDeclarationValue {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$assignment, $expression] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                assignment: new YulAssignmentOperator($assignment),
                expression: new YulExpression($expression),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulVariableDeclarationValue);
    }
    get assignment() {
        return this.fetch().assignment;
    }
    get expression() {
        return this.fetch().expression;
    }
}
exports.YulVariableDeclarationValue = YulVariableDeclarationValue;
class YulVariableAssignmentStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$names, $assignment, $expression] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                names: new YulPaths($names),
                assignment: new YulAssignmentOperator($assignment),
                expression: new YulExpression($expression),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulVariableAssignmentStatement);
    }
    get names() {
        return this.fetch().names;
    }
    get assignment() {
        return this.fetch().assignment;
    }
    get expression() {
        return this.fetch().expression;
    }
}
exports.YulVariableAssignmentStatement = YulVariableAssignmentStatement;
class YulStackAssignmentStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$assignment, $expression] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                assignment: new YulAssignmentOperator($assignment),
                expression: new YulExpression($expression),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulStackAssignmentStatement);
    }
    get assignment() {
        return this.fetch().assignment;
    }
    get expression() {
        return this.fetch().expression;
    }
}
exports.YulStackAssignmentStatement = YulStackAssignmentStatement;
class YulColonEqual {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$colon, $equal] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                colon: $colon,
                equal: $equal,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulColonEqual);
    }
    get colon() {
        return this.fetch().colon;
    }
    get equal() {
        return this.fetch().equal;
    }
}
exports.YulColonEqual = YulColonEqual;
class YulIfStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$ifKeyword, $condition, $body] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                ifKeyword: $ifKeyword,
                condition: new YulExpression($condition),
                body: new YulBlock($body),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulIfStatement);
    }
    get ifKeyword() {
        return this.fetch().ifKeyword;
    }
    get condition() {
        return this.fetch().condition;
    }
    get body() {
        return this.fetch().body;
    }
}
exports.YulIfStatement = YulIfStatement;
class YulForStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$forKeyword, $initialization, $condition, $iterator, $body] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                forKeyword: $forKeyword,
                initialization: new YulBlock($initialization),
                condition: new YulExpression($condition),
                iterator: new YulBlock($iterator),
                body: new YulBlock($body),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulForStatement);
    }
    get forKeyword() {
        return this.fetch().forKeyword;
    }
    get initialization() {
        return this.fetch().initialization;
    }
    get condition() {
        return this.fetch().condition;
    }
    get iterator() {
        return this.fetch().iterator;
    }
    get body() {
        return this.fetch().body;
    }
}
exports.YulForStatement = YulForStatement;
class YulSwitchStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$switchKeyword, $expression, $cases] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                switchKeyword: $switchKeyword,
                expression: new YulExpression($expression),
                cases: new YulSwitchCases($cases),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulSwitchStatement);
    }
    get switchKeyword() {
        return this.fetch().switchKeyword;
    }
    get expression() {
        return this.fetch().expression;
    }
    get cases() {
        return this.fetch().cases;
    }
}
exports.YulSwitchStatement = YulSwitchStatement;
class YulDefaultCase {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$defaultKeyword, $body] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                defaultKeyword: $defaultKeyword,
                body: new YulBlock($body),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulDefaultCase);
    }
    get defaultKeyword() {
        return this.fetch().defaultKeyword;
    }
    get body() {
        return this.fetch().body;
    }
}
exports.YulDefaultCase = YulDefaultCase;
class YulValueCase {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$caseKeyword, $value, $body] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                caseKeyword: $caseKeyword,
                value: new YulLiteral($value),
                body: new YulBlock($body),
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulValueCase);
    }
    get caseKeyword() {
        return this.fetch().caseKeyword;
    }
    get value() {
        return this.fetch().value;
    }
    get body() {
        return this.fetch().body;
    }
}
exports.YulValueCase = YulValueCase;
class YulLeaveStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leaveKeyword] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                leaveKeyword: $leaveKeyword,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulLeaveStatement);
    }
    get leaveKeyword() {
        return this.fetch().leaveKeyword;
    }
}
exports.YulLeaveStatement = YulLeaveStatement;
class YulBreakStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$breakKeyword] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                breakKeyword: $breakKeyword,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulBreakStatement);
    }
    get breakKeyword() {
        return this.fetch().breakKeyword;
    }
}
exports.YulBreakStatement = YulBreakStatement;
class YulContinueStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$continueKeyword] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                continueKeyword: $continueKeyword,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulContinueStatement);
    }
    get continueKeyword() {
        return this.fetch().continueKeyword;
    }
}
exports.YulContinueStatement = YulContinueStatement;
class YulLabel {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$label, $colon] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                label: $label,
                colon: $colon,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulLabel);
    }
    get label() {
        return this.fetch().label;
    }
    get colon() {
        return this.fetch().colon;
    }
}
exports.YulLabel = YulLabel;
class YulFunctionCallExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operand, $openParen, $arguments, $closeParen] = generated_1.ast_internal.selectSequence(this.cst);
            return {
                operand: new YulExpression($operand),
                openParen: $openParen,
                arguments: new YulArguments($arguments),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulFunctionCallExpression);
    }
    get operand() {
        return this.fetch().operand;
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get arguments() {
        return this.fetch().arguments;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
exports.YulFunctionCallExpression = YulFunctionCallExpression;
/*
 * Choices:
 */
class SourceUnitMember {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            switch (variant.kind) {
                case kinds_1.NonterminalKind.PragmaDirective:
                    return new PragmaDirective(variant);
                case kinds_1.NonterminalKind.ImportDirective:
                    return new ImportDirective(variant);
                case kinds_1.NonterminalKind.ContractDefinition:
                    return new ContractDefinition(variant);
                case kinds_1.NonterminalKind.InterfaceDefinition:
                    return new InterfaceDefinition(variant);
                case kinds_1.NonterminalKind.LibraryDefinition:
                    return new LibraryDefinition(variant);
                case kinds_1.NonterminalKind.StructDefinition:
                    return new StructDefinition(variant);
                case kinds_1.NonterminalKind.EnumDefinition:
                    return new EnumDefinition(variant);
                case kinds_1.NonterminalKind.FunctionDefinition:
                    return new FunctionDefinition(variant);
                case kinds_1.NonterminalKind.ConstantDefinition:
                    return new ConstantDefinition(variant);
                case kinds_1.NonterminalKind.ErrorDefinition:
                    return new ErrorDefinition(variant);
                case kinds_1.NonterminalKind.UserDefinedValueTypeDefinition:
                    return new UserDefinedValueTypeDefinition(variant);
                case kinds_1.NonterminalKind.UsingDirective:
                    return new UsingDirective(variant);
                case kinds_1.NonterminalKind.EventDefinition:
                    return new EventDefinition(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.SourceUnitMember);
    }
    get variant() {
        return this.fetch();
    }
}
exports.SourceUnitMember = SourceUnitMember;
class Pragma {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            switch (variant.kind) {
                case kinds_1.NonterminalKind.ABICoderPragma:
                    return new ABICoderPragma(variant);
                case kinds_1.NonterminalKind.ExperimentalPragma:
                    return new ExperimentalPragma(variant);
                case kinds_1.NonterminalKind.VersionPragma:
                    return new VersionPragma(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.Pragma);
    }
    get variant() {
        return this.fetch();
    }
}
exports.Pragma = Pragma;
class ExperimentalFeature {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.StringLiteral:
                    return new StringLiteral(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ExperimentalFeature);
    }
    get variant() {
        return this.fetch();
    }
}
exports.ExperimentalFeature = ExperimentalFeature;
class VersionExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.VersionRange:
                    return new VersionRange(variant);
                case kinds_1.NonterminalKind.VersionComparator:
                    return new VersionComparator(variant);
                case kinds_1.NonterminalKind.VersionSpecifiers:
                    return new VersionSpecifiers(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.VersionExpression);
    }
    get variant() {
        return this.fetch();
    }
}
exports.VersionExpression = VersionExpression;
class ImportClause {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            switch (variant.kind) {
                case kinds_1.NonterminalKind.PathImport:
                    return new PathImport(variant);
                case kinds_1.NonterminalKind.NamedImport:
                    return new NamedImport(variant);
                case kinds_1.NonterminalKind.ImportDeconstruction:
                    return new ImportDeconstruction(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ImportClause);
    }
    get variant() {
        return this.fetch();
    }
}
exports.ImportClause = ImportClause;
class UsingClause {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            switch (variant.kind) {
                case kinds_1.NonterminalKind.IdentifierPath:
                    return new IdentifierPath(variant);
                case kinds_1.NonterminalKind.UsingDeconstruction:
                    return new UsingDeconstruction(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.UsingClause);
    }
    get variant() {
        return this.fetch();
    }
}
exports.UsingClause = UsingClause;
class UsingOperator {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.UsingOperator);
    }
    get variant() {
        return this.fetch();
    }
}
exports.UsingOperator = UsingOperator;
class UsingTarget {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.TypeName:
                    return new TypeName(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.UsingTarget);
    }
    get variant() {
        return this.fetch();
    }
}
exports.UsingTarget = UsingTarget;
class ContractMember {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            switch (variant.kind) {
                case kinds_1.NonterminalKind.UsingDirective:
                    return new UsingDirective(variant);
                case kinds_1.NonterminalKind.FunctionDefinition:
                    return new FunctionDefinition(variant);
                case kinds_1.NonterminalKind.ConstructorDefinition:
                    return new ConstructorDefinition(variant);
                case kinds_1.NonterminalKind.ReceiveFunctionDefinition:
                    return new ReceiveFunctionDefinition(variant);
                case kinds_1.NonterminalKind.FallbackFunctionDefinition:
                    return new FallbackFunctionDefinition(variant);
                case kinds_1.NonterminalKind.UnnamedFunctionDefinition:
                    return new UnnamedFunctionDefinition(variant);
                case kinds_1.NonterminalKind.ModifierDefinition:
                    return new ModifierDefinition(variant);
                case kinds_1.NonterminalKind.StructDefinition:
                    return new StructDefinition(variant);
                case kinds_1.NonterminalKind.EnumDefinition:
                    return new EnumDefinition(variant);
                case kinds_1.NonterminalKind.EventDefinition:
                    return new EventDefinition(variant);
                case kinds_1.NonterminalKind.StateVariableDefinition:
                    return new StateVariableDefinition(variant);
                case kinds_1.NonterminalKind.ErrorDefinition:
                    return new ErrorDefinition(variant);
                case kinds_1.NonterminalKind.UserDefinedValueTypeDefinition:
                    return new UserDefinedValueTypeDefinition(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ContractMember);
    }
    get variant() {
        return this.fetch();
    }
}
exports.ContractMember = ContractMember;
class StateVariableAttribute {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.OverrideSpecifier:
                    return new OverrideSpecifier(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.StateVariableAttribute);
    }
    get variant() {
        return this.fetch();
    }
}
exports.StateVariableAttribute = StateVariableAttribute;
class FunctionName {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.FunctionName);
    }
    get variant() {
        return this.fetch();
    }
}
exports.FunctionName = FunctionName;
class FunctionAttribute {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.ModifierInvocation:
                    return new ModifierInvocation(variant);
                case kinds_1.NonterminalKind.OverrideSpecifier:
                    return new OverrideSpecifier(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.FunctionAttribute);
    }
    get variant() {
        return this.fetch();
    }
}
exports.FunctionAttribute = FunctionAttribute;
class FunctionBody {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.Block:
                    return new Block(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.FunctionBody);
    }
    get variant() {
        return this.fetch();
    }
}
exports.FunctionBody = FunctionBody;
class ConstructorAttribute {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.ModifierInvocation:
                    return new ModifierInvocation(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ConstructorAttribute);
    }
    get variant() {
        return this.fetch();
    }
}
exports.ConstructorAttribute = ConstructorAttribute;
class UnnamedFunctionAttribute {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.ModifierInvocation:
                    return new ModifierInvocation(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.UnnamedFunctionAttribute);
    }
    get variant() {
        return this.fetch();
    }
}
exports.UnnamedFunctionAttribute = UnnamedFunctionAttribute;
class FallbackFunctionAttribute {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.ModifierInvocation:
                    return new ModifierInvocation(variant);
                case kinds_1.NonterminalKind.OverrideSpecifier:
                    return new OverrideSpecifier(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.FallbackFunctionAttribute);
    }
    get variant() {
        return this.fetch();
    }
}
exports.FallbackFunctionAttribute = FallbackFunctionAttribute;
class ReceiveFunctionAttribute {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.ModifierInvocation:
                    return new ModifierInvocation(variant);
                case kinds_1.NonterminalKind.OverrideSpecifier:
                    return new OverrideSpecifier(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ReceiveFunctionAttribute);
    }
    get variant() {
        return this.fetch();
    }
}
exports.ReceiveFunctionAttribute = ReceiveFunctionAttribute;
class ModifierAttribute {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.OverrideSpecifier:
                    return new OverrideSpecifier(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ModifierAttribute);
    }
    get variant() {
        return this.fetch();
    }
}
exports.ModifierAttribute = ModifierAttribute;
class TypeName {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            switch (variant.kind) {
                case kinds_1.NonterminalKind.ArrayTypeName:
                    return new ArrayTypeName(variant);
                case kinds_1.NonterminalKind.FunctionType:
                    return new FunctionType(variant);
                case kinds_1.NonterminalKind.MappingType:
                    return new MappingType(variant);
                case kinds_1.NonterminalKind.ElementaryType:
                    return new ElementaryType(variant);
                case kinds_1.NonterminalKind.IdentifierPath:
                    return new IdentifierPath(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.TypeName);
    }
    get variant() {
        return this.fetch();
    }
}
exports.TypeName = TypeName;
class FunctionTypeAttribute {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.FunctionTypeAttribute);
    }
    get variant() {
        return this.fetch();
    }
}
exports.FunctionTypeAttribute = FunctionTypeAttribute;
class MappingKeyType {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            switch (variant.kind) {
                case kinds_1.NonterminalKind.ElementaryType:
                    return new ElementaryType(variant);
                case kinds_1.NonterminalKind.IdentifierPath:
                    return new IdentifierPath(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.MappingKeyType);
    }
    get variant() {
        return this.fetch();
    }
}
exports.MappingKeyType = MappingKeyType;
class ElementaryType {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.AddressType:
                    return new AddressType(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ElementaryType);
    }
    get variant() {
        return this.fetch();
    }
}
exports.ElementaryType = ElementaryType;
class Statement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            switch (variant.kind) {
                case kinds_1.NonterminalKind.ExpressionStatement:
                    return new ExpressionStatement(variant);
                case kinds_1.NonterminalKind.VariableDeclarationStatement:
                    return new VariableDeclarationStatement(variant);
                case kinds_1.NonterminalKind.TupleDeconstructionStatement:
                    return new TupleDeconstructionStatement(variant);
                case kinds_1.NonterminalKind.IfStatement:
                    return new IfStatement(variant);
                case kinds_1.NonterminalKind.ForStatement:
                    return new ForStatement(variant);
                case kinds_1.NonterminalKind.WhileStatement:
                    return new WhileStatement(variant);
                case kinds_1.NonterminalKind.DoWhileStatement:
                    return new DoWhileStatement(variant);
                case kinds_1.NonterminalKind.ContinueStatement:
                    return new ContinueStatement(variant);
                case kinds_1.NonterminalKind.BreakStatement:
                    return new BreakStatement(variant);
                case kinds_1.NonterminalKind.ReturnStatement:
                    return new ReturnStatement(variant);
                case kinds_1.NonterminalKind.ThrowStatement:
                    return new ThrowStatement(variant);
                case kinds_1.NonterminalKind.EmitStatement:
                    return new EmitStatement(variant);
                case kinds_1.NonterminalKind.TryStatement:
                    return new TryStatement(variant);
                case kinds_1.NonterminalKind.RevertStatement:
                    return new RevertStatement(variant);
                case kinds_1.NonterminalKind.AssemblyStatement:
                    return new AssemblyStatement(variant);
                case kinds_1.NonterminalKind.Block:
                    return new Block(variant);
                case kinds_1.NonterminalKind.UncheckedBlock:
                    return new UncheckedBlock(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.Statement);
    }
    get variant() {
        return this.fetch();
    }
}
exports.Statement = Statement;
class TupleMember {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            switch (variant.kind) {
                case kinds_1.NonterminalKind.TypedTupleMember:
                    return new TypedTupleMember(variant);
                case kinds_1.NonterminalKind.UntypedTupleMember:
                    return new UntypedTupleMember(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.TupleMember);
    }
    get variant() {
        return this.fetch();
    }
}
exports.TupleMember = TupleMember;
class VariableDeclarationType {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.TypeName:
                    return new TypeName(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.VariableDeclarationType);
    }
    get variant() {
        return this.fetch();
    }
}
exports.VariableDeclarationType = VariableDeclarationType;
class StorageLocation {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.StorageLocation);
    }
    get variant() {
        return this.fetch();
    }
}
exports.StorageLocation = StorageLocation;
class ForStatementInitialization {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.ExpressionStatement:
                    return new ExpressionStatement(variant);
                case kinds_1.NonterminalKind.VariableDeclarationStatement:
                    return new VariableDeclarationStatement(variant);
                case kinds_1.NonterminalKind.TupleDeconstructionStatement:
                    return new TupleDeconstructionStatement(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ForStatementInitialization);
    }
    get variant() {
        return this.fetch();
    }
}
exports.ForStatementInitialization = ForStatementInitialization;
class ForStatementCondition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.ExpressionStatement:
                    return new ExpressionStatement(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ForStatementCondition);
    }
    get variant() {
        return this.fetch();
    }
}
exports.ForStatementCondition = ForStatementCondition;
class Expression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.AssignmentExpression:
                    return new AssignmentExpression(variant);
                case kinds_1.NonterminalKind.ConditionalExpression:
                    return new ConditionalExpression(variant);
                case kinds_1.NonterminalKind.OrExpression:
                    return new OrExpression(variant);
                case kinds_1.NonterminalKind.AndExpression:
                    return new AndExpression(variant);
                case kinds_1.NonterminalKind.EqualityExpression:
                    return new EqualityExpression(variant);
                case kinds_1.NonterminalKind.ComparisonExpression:
                    return new ComparisonExpression(variant);
                case kinds_1.NonterminalKind.BitwiseOrExpression:
                    return new BitwiseOrExpression(variant);
                case kinds_1.NonterminalKind.BitwiseXorExpression:
                    return new BitwiseXorExpression(variant);
                case kinds_1.NonterminalKind.BitwiseAndExpression:
                    return new BitwiseAndExpression(variant);
                case kinds_1.NonterminalKind.ShiftExpression:
                    return new ShiftExpression(variant);
                case kinds_1.NonterminalKind.AdditiveExpression:
                    return new AdditiveExpression(variant);
                case kinds_1.NonterminalKind.MultiplicativeExpression:
                    return new MultiplicativeExpression(variant);
                case kinds_1.NonterminalKind.ExponentiationExpression:
                    return new ExponentiationExpression(variant);
                case kinds_1.NonterminalKind.PostfixExpression:
                    return new PostfixExpression(variant);
                case kinds_1.NonterminalKind.PrefixExpression:
                    return new PrefixExpression(variant);
                case kinds_1.NonterminalKind.FunctionCallExpression:
                    return new FunctionCallExpression(variant);
                case kinds_1.NonterminalKind.CallOptionsExpression:
                    return new CallOptionsExpression(variant);
                case kinds_1.NonterminalKind.MemberAccessExpression:
                    return new MemberAccessExpression(variant);
                case kinds_1.NonterminalKind.IndexAccessExpression:
                    return new IndexAccessExpression(variant);
                case kinds_1.NonterminalKind.NewExpression:
                    return new NewExpression(variant);
                case kinds_1.NonterminalKind.TupleExpression:
                    return new TupleExpression(variant);
                case kinds_1.NonterminalKind.TypeExpression:
                    return new TypeExpression(variant);
                case kinds_1.NonterminalKind.ArrayExpression:
                    return new ArrayExpression(variant);
                case kinds_1.NonterminalKind.HexNumberExpression:
                    return new HexNumberExpression(variant);
                case kinds_1.NonterminalKind.DecimalNumberExpression:
                    return new DecimalNumberExpression(variant);
                case kinds_1.NonterminalKind.StringExpression:
                    return new StringExpression(variant);
                case kinds_1.NonterminalKind.ElementaryType:
                    return new ElementaryType(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.Expression);
    }
    get variant() {
        return this.fetch();
    }
}
exports.Expression = Expression;
class MemberAccess {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.MemberAccess);
    }
    get variant() {
        return this.fetch();
    }
}
exports.MemberAccess = MemberAccess;
class ArgumentsDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            switch (variant.kind) {
                case kinds_1.NonterminalKind.PositionalArgumentsDeclaration:
                    return new PositionalArgumentsDeclaration(variant);
                case kinds_1.NonterminalKind.NamedArgumentsDeclaration:
                    return new NamedArgumentsDeclaration(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ArgumentsDeclaration);
    }
    get variant() {
        return this.fetch();
    }
}
exports.ArgumentsDeclaration = ArgumentsDeclaration;
class NumberUnit {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.NumberUnit);
    }
    get variant() {
        return this.fetch();
    }
}
exports.NumberUnit = NumberUnit;
class StringExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            switch (variant.kind) {
                case kinds_1.NonterminalKind.StringLiteral:
                    return new StringLiteral(variant);
                case kinds_1.NonterminalKind.StringLiterals:
                    return new StringLiterals(variant);
                case kinds_1.NonterminalKind.HexStringLiteral:
                    return new HexStringLiteral(variant);
                case kinds_1.NonterminalKind.HexStringLiterals:
                    return new HexStringLiterals(variant);
                case kinds_1.NonterminalKind.UnicodeStringLiterals:
                    return new UnicodeStringLiterals(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.StringExpression);
    }
    get variant() {
        return this.fetch();
    }
}
exports.StringExpression = StringExpression;
class StringLiteral {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.StringLiteral);
    }
    get variant() {
        return this.fetch();
    }
}
exports.StringLiteral = StringLiteral;
class HexStringLiteral {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.HexStringLiteral);
    }
    get variant() {
        return this.fetch();
    }
}
exports.HexStringLiteral = HexStringLiteral;
class UnicodeStringLiteral {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.UnicodeStringLiteral);
    }
    get variant() {
        return this.fetch();
    }
}
exports.UnicodeStringLiteral = UnicodeStringLiteral;
class YulStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            switch (variant.kind) {
                case kinds_1.NonterminalKind.YulBlock:
                    return new YulBlock(variant);
                case kinds_1.NonterminalKind.YulFunctionDefinition:
                    return new YulFunctionDefinition(variant);
                case kinds_1.NonterminalKind.YulVariableDeclarationStatement:
                    return new YulVariableDeclarationStatement(variant);
                case kinds_1.NonterminalKind.YulVariableAssignmentStatement:
                    return new YulVariableAssignmentStatement(variant);
                case kinds_1.NonterminalKind.YulStackAssignmentStatement:
                    return new YulStackAssignmentStatement(variant);
                case kinds_1.NonterminalKind.YulIfStatement:
                    return new YulIfStatement(variant);
                case kinds_1.NonterminalKind.YulForStatement:
                    return new YulForStatement(variant);
                case kinds_1.NonterminalKind.YulSwitchStatement:
                    return new YulSwitchStatement(variant);
                case kinds_1.NonterminalKind.YulLeaveStatement:
                    return new YulLeaveStatement(variant);
                case kinds_1.NonterminalKind.YulBreakStatement:
                    return new YulBreakStatement(variant);
                case kinds_1.NonterminalKind.YulContinueStatement:
                    return new YulContinueStatement(variant);
                case kinds_1.NonterminalKind.YulLabel:
                    return new YulLabel(variant);
                case kinds_1.NonterminalKind.YulExpression:
                    return new YulExpression(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulStatement);
    }
    get variant() {
        return this.fetch();
    }
}
exports.YulStatement = YulStatement;
class YulAssignmentOperator {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.YulColonEqual:
                    return new YulColonEqual(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulAssignmentOperator);
    }
    get variant() {
        return this.fetch();
    }
}
exports.YulAssignmentOperator = YulAssignmentOperator;
class YulSwitchCase {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            switch (variant.kind) {
                case kinds_1.NonterminalKind.YulDefaultCase:
                    return new YulDefaultCase(variant);
                case kinds_1.NonterminalKind.YulValueCase:
                    return new YulValueCase(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulSwitchCase);
    }
    get variant() {
        return this.fetch();
    }
}
exports.YulSwitchCase = YulSwitchCase;
class YulExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            switch (variant.kind) {
                case kinds_1.NonterminalKind.YulFunctionCallExpression:
                    return new YulFunctionCallExpression(variant);
                case kinds_1.NonterminalKind.YulLiteral:
                    return new YulLiteral(variant);
                case kinds_1.NonterminalKind.YulBuiltInFunction:
                    return new YulBuiltInFunction(variant);
                case kinds_1.NonterminalKind.YulPath:
                    return new YulPath(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulExpression);
    }
    get variant() {
        return this.fetch();
    }
}
exports.YulExpression = YulExpression;
class YulPathComponent {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulPathComponent);
    }
    get variant() {
        return this.fetch();
    }
}
exports.YulPathComponent = YulPathComponent;
class YulBuiltInFunction {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulBuiltInFunction);
    }
    get variant() {
        return this.fetch();
    }
}
exports.YulBuiltInFunction = YulBuiltInFunction;
class YulLiteral {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated_1.ast_internal.selectChoice(this.cst);
            if (variant.type == cst_1.NodeType.Terminal) {
                return variant;
            }
            switch (variant.kind) {
                case kinds_1.NonterminalKind.HexStringLiteral:
                    return new HexStringLiteral(variant);
                case kinds_1.NonterminalKind.StringLiteral:
                    return new StringLiteral(variant);
                default:
                    assert.fail(`Unexpected variant: ${variant.kind}`);
            }
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulLiteral);
    }
    get variant() {
        return this.fetch();
    }
}
exports.YulLiteral = YulLiteral;
/*
 * Repeated:
 */
class SourceUnitMembers {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new SourceUnitMember(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.SourceUnitMembers);
    }
    get items() {
        return this.fetch();
    }
}
exports.SourceUnitMembers = SourceUnitMembers;
class VersionExpressionSet {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new VersionExpression(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.VersionExpressionSet);
    }
    get items() {
        return this.fetch();
    }
}
exports.VersionExpressionSet = VersionExpressionSet;
class ContractMembers {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new ContractMember(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ContractMembers);
    }
    get items() {
        return this.fetch();
    }
}
exports.ContractMembers = ContractMembers;
class InterfaceMembers {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new ContractMember(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.InterfaceMembers);
    }
    get items() {
        return this.fetch();
    }
}
exports.InterfaceMembers = InterfaceMembers;
class LibraryMembers {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new ContractMember(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.LibraryMembers);
    }
    get items() {
        return this.fetch();
    }
}
exports.LibraryMembers = LibraryMembers;
class StructMembers {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new StructMember(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.StructMembers);
    }
    get items() {
        return this.fetch();
    }
}
exports.StructMembers = StructMembers;
class StateVariableAttributes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new StateVariableAttribute(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.StateVariableAttributes);
    }
    get items() {
        return this.fetch();
    }
}
exports.StateVariableAttributes = StateVariableAttributes;
class FunctionAttributes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new FunctionAttribute(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.FunctionAttributes);
    }
    get items() {
        return this.fetch();
    }
}
exports.FunctionAttributes = FunctionAttributes;
class ConstructorAttributes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new ConstructorAttribute(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ConstructorAttributes);
    }
    get items() {
        return this.fetch();
    }
}
exports.ConstructorAttributes = ConstructorAttributes;
class UnnamedFunctionAttributes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new UnnamedFunctionAttribute(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.UnnamedFunctionAttributes);
    }
    get items() {
        return this.fetch();
    }
}
exports.UnnamedFunctionAttributes = UnnamedFunctionAttributes;
class FallbackFunctionAttributes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new FallbackFunctionAttribute(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.FallbackFunctionAttributes);
    }
    get items() {
        return this.fetch();
    }
}
exports.FallbackFunctionAttributes = FallbackFunctionAttributes;
class ReceiveFunctionAttributes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new ReceiveFunctionAttribute(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ReceiveFunctionAttributes);
    }
    get items() {
        return this.fetch();
    }
}
exports.ReceiveFunctionAttributes = ReceiveFunctionAttributes;
class ModifierAttributes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new ModifierAttribute(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ModifierAttributes);
    }
    get items() {
        return this.fetch();
    }
}
exports.ModifierAttributes = ModifierAttributes;
class FunctionTypeAttributes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new FunctionTypeAttribute(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.FunctionTypeAttributes);
    }
    get items() {
        return this.fetch();
    }
}
exports.FunctionTypeAttributes = FunctionTypeAttributes;
class Statements {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new Statement(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.Statements);
    }
    get items() {
        return this.fetch();
    }
}
exports.Statements = Statements;
class CatchClauses {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new CatchClause(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.CatchClauses);
    }
    get items() {
        return this.fetch();
    }
}
exports.CatchClauses = CatchClauses;
class StringLiterals {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new StringLiteral(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.StringLiterals);
    }
    get items() {
        return this.fetch();
    }
}
exports.StringLiterals = StringLiterals;
class HexStringLiterals {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new HexStringLiteral(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.HexStringLiterals);
    }
    get items() {
        return this.fetch();
    }
}
exports.HexStringLiterals = HexStringLiterals;
class UnicodeStringLiterals {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new UnicodeStringLiteral(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.UnicodeStringLiterals);
    }
    get items() {
        return this.fetch();
    }
}
exports.UnicodeStringLiterals = UnicodeStringLiterals;
class YulStatements {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new YulStatement(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulStatements);
    }
    get items() {
        return this.fetch();
    }
}
exports.YulStatements = YulStatements;
class YulSwitchCases {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated_1.ast_internal.selectRepeated(this.cst);
            return items.map((item) => new YulSwitchCase(item));
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulSwitchCases);
    }
    get items() {
        return this.fetch();
    }
}
exports.YulSwitchCases = YulSwitchCases;
/*
 * Separated:
 */
class VersionExpressionSets {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new VersionExpressionSet(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.VersionExpressionSets);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.VersionExpressionSets = VersionExpressionSets;
class VersionSpecifiers {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return { items: items, separators: separators };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.VersionSpecifiers);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.VersionSpecifiers = VersionSpecifiers;
class ImportDeconstructionSymbols {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new ImportDeconstructionSymbol(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ImportDeconstructionSymbols);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.ImportDeconstructionSymbols = ImportDeconstructionSymbols;
class UsingDeconstructionSymbols {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new UsingDeconstructionSymbol(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.UsingDeconstructionSymbols);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.UsingDeconstructionSymbols = UsingDeconstructionSymbols;
class InheritanceTypes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new InheritanceType(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.InheritanceTypes);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.InheritanceTypes = InheritanceTypes;
class EnumMembers {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return { items: items, separators: separators };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.EnumMembers);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.EnumMembers = EnumMembers;
class Parameters {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new Parameter(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.Parameters);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.Parameters = Parameters;
class OverridePaths {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new IdentifierPath(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.OverridePaths);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.OverridePaths = OverridePaths;
class EventParameters {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new EventParameter(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.EventParameters);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.EventParameters = EventParameters;
class ErrorParameters {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new ErrorParameter(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ErrorParameters);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.ErrorParameters = ErrorParameters;
class AssemblyFlags {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new StringLiteral(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.AssemblyFlags);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.AssemblyFlags = AssemblyFlags;
class TupleDeconstructionElements {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new TupleDeconstructionElement(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.TupleDeconstructionElements);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.TupleDeconstructionElements = TupleDeconstructionElements;
class PositionalArguments {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new Expression(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.PositionalArguments);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.PositionalArguments = PositionalArguments;
class NamedArguments {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new NamedArgument(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.NamedArguments);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.NamedArguments = NamedArguments;
class CallOptions {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new NamedArgument(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.CallOptions);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.CallOptions = CallOptions;
class TupleValues {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new TupleValue(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.TupleValues);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.TupleValues = TupleValues;
class ArrayValues {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new Expression(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.ArrayValues);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.ArrayValues = ArrayValues;
class IdentifierPath {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return { items: items, separators: separators };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.IdentifierPath);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.IdentifierPath = IdentifierPath;
class YulParameters {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return { items: items, separators: separators };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulParameters);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.YulParameters = YulParameters;
class YulReturnVariables {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return { items: items, separators: separators };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulReturnVariables);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.YulReturnVariables = YulReturnVariables;
class YulArguments {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new YulExpression(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulArguments);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.YulArguments = YulArguments;
class YulPaths {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new YulPath(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulPaths);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.YulPaths = YulPaths;
class YulPath {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated_1.ast_internal.selectSeparated(this.cst);
            return {
                items: items.map((item) => new YulPathComponent(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, kinds_1.NonterminalKind.YulPath);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
exports.YulPath = YulPath;
/*
 * Helpers:
 */
function once(factory) {
    let value;
    return () => {
        if (value === undefined) {
            value = factory();
        }
        return value;
    };
}
function assertKind(actual, expected) {
    assert.equal(actual, expected, `${expected} can only be initialized with a CST node of the same kind.`);
}
