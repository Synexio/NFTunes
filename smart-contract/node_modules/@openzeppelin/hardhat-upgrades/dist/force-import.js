"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeForceImport = makeForceImport;
const upgrades_core_1 = require("@openzeppelin/upgrades-core");
const utils_1 = require("./utils");
const deploy_impl_1 = require("./utils/deploy-impl");
const ethers_1 = require("./utils/ethers");
function makeForceImport(hre) {
    return async function forceImport(addressOrInstance, ImplFactory, opts = {}) {
        const { provider } = hre.network;
        const manifest = await upgrades_core_1.Manifest.forNetwork(provider);
        const address = await (0, utils_1.getContractAddress)(addressOrInstance);
        const implAddress = await (0, upgrades_core_1.getImplementationAddressFromProxy)(provider, address);
        if (implAddress !== undefined) {
            await importProxyToManifest(provider, hre, address, implAddress, ImplFactory, opts, manifest);
            return (0, ethers_1.attach)(ImplFactory, address);
        }
        else if (await (0, upgrades_core_1.isBeacon)(provider, address)) {
            const beaconImplAddress = await (0, upgrades_core_1.getImplementationAddressFromBeacon)(provider, address);
            await addImplToManifest(hre, beaconImplAddress, ImplFactory, opts);
            const UpgradeableBeaconFactory = await (0, utils_1.getUpgradeableBeaconFactory)(hre, (0, ethers_1.getSigner)(ImplFactory.runner));
            return (0, ethers_1.attach)(UpgradeableBeaconFactory, address);
        }
        else {
            if (!(await (0, upgrades_core_1.hasCode)(provider, address))) {
                throw new upgrades_core_1.NoContractImportError(address);
            }
            await addImplToManifest(hre, address, ImplFactory, opts);
            return (0, ethers_1.attach)(ImplFactory, address);
        }
    };
}
async function importProxyToManifest(provider, hre, proxyAddress, implAddress, ImplFactory, opts, manifest) {
    await addImplToManifest(hre, implAddress, ImplFactory, opts);
    let importKind;
    if (opts.kind === undefined) {
        if (await (0, upgrades_core_1.isBeaconProxy)(provider, proxyAddress)) {
            importKind = 'beacon';
        }
        else {
            const deployData = await (0, deploy_impl_1.getDeployData)(hre, ImplFactory, opts);
            importKind = (0, upgrades_core_1.inferProxyKind)(deployData.validations, deployData.version);
        }
    }
    else {
        importKind = opts.kind;
    }
    if (importKind === 'transparent') {
        await assertNonEmptyAdminSlot(provider, proxyAddress);
    }
    await (0, upgrades_core_1.addProxyToManifest)(importKind, proxyAddress, manifest);
}
async function addImplToManifest(hre, implAddress, ImplFactory, opts) {
    await (0, utils_1.simulateDeployImpl)(hre, ImplFactory, opts, implAddress);
}
async function assertNonEmptyAdminSlot(provider, proxyAddress) {
    const adminAddress = await (0, upgrades_core_1.getAdminAddress)(provider, proxyAddress);
    if ((0, upgrades_core_1.isEmptySlot)(adminAddress)) {
        // Assert that the admin slot of a transparent proxy is not zero, otherwise the wrong kind may be imported.
        // Note: Transparent proxies should not have the zero address as the admin, according to TransparentUpgradeableProxy's _setAdmin function.
        throw new upgrades_core_1.UpgradesError(`Proxy at ${proxyAddress} doesn't look like a transparent proxy`, () => `The proxy doesn't look like a transparent proxy because its admin address slot is empty. ` +
            `Set the \`kind\` option to the kind of proxy that was deployed at ${proxyAddress} (either 'uups' or 'beacon')`);
    }
}
//# sourceMappingURL=force-import.js.map